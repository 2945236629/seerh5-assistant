# 名词声明

`sac`:SeerH5-Assistant-Core

`seer`:赛尔号暴露的api

`ct/catchtime`:赛尔号对玩家精灵实体的唯一标识

# 功能点

说明：这一节说明SeerH5-Assistant-Core，即赛尔h5辅助（没想好名字）核心库所要实现的基本功能，同时包括内部和外部功能，涉及实现的设计，但是不包括具体接口的说明。

不在此处说明的模块包括logger，common，export，index，constant。

全局变量全部包含在命名空间sac下。

具体接口声明见导出的dts。

## 1. 操作引擎模块（`\Engine`）

本部分实现并封装绝大部分需要seer直接交互的功能。注意是绝大部分，一小部分的功能由于其特殊性，由其他模块实现并管理（如精灵管理和战斗管理，相关逻辑由模块内部进行耦合）。

另外注意引擎的操作不会涉及ui操作，这是因为seer中ui层（egret实现）也是和底层逻辑业务层分离的，可见所有的ui功能都能对应到一组底层操作。且本引擎目前不涉及cv处理（计算机视觉），显然在这种情况下，通过ui对象来进行操作的实现是不好的，会使底层实现混乱。这部分目前有一些特例，但是在该模块下，不能出现ui相关的操作。

主要包括以下部分:

- 收发包（`engine\socket.ts`）
  - 发包（sendByQueue）
  - 查询Value
  - 查询Bit
  - 查询PlayerInfo

均返回原生promise

- 查询静态数据（`engine\game-data.ts`）
  - 精灵
  - 技能
  - 属性
  - 物品
  - 套装
  - 称号

所有的静态数据返回的都是原始对象，即seer内部使用的对象，常用类型已经在主项目的type下定义

- 查询动态数据（`engine\player-data.ts`）
  - 火焰
  - 物品列表
  - 套装列表
  - 称号列表
  - 查物品数量 id/对象 后面都是这种模式

所有的查询返回promise，注意promise是在收到包后才resolve，而不是发出后就返回，部分promise resolve的内容会直接经过序列化为**sac的**实体类

- 更改动态数据（`engine\action.ts`）

这部分功能比较杂，但是在实现时保证做到：

- 返回的均为promise，收包后才resolve
- **只**涉及一个底层发包
- 如果可能，提供游戏内缓存换取和实时更新获取两种获得动态数据的接口
  - 使用上，理解为如果游戏内部在获取此类数据的时候，使用了某些缓存机制，并且提供了非异步的调用接口，那么考虑合适的使用场景下，sac也将提供两个版本的函数：异步调用，获取最新值并且**更新游戏客户端的缓存**；以及同步调用，直接从游戏客户端缓存获取数据。
  - 如果游戏内部获取此类数据是每次都进行发包请求，那么就只会提供一个异步调用，直接获取最新数据的接口。

- 和battle与pet相关的功能不在这个模块下提供



## 2. 实体封装`\Entity`

提供seer原始实体对象到sac实体类的封装，并静态提供常用工厂函数。

如果没有特别指明，提到实体对象，均指sac的封装对象。

主要包括以下实体：

- 战斗信息`RoundInfo`
- 精灵`Pet`
- 技能`Skill`，支持一些计算属性
- 物品`Item`
- 属性`PetType`，支持一些计算属性
- 精灵因子关卡`PetFragmentLevel`

所有的默认构造函数为对应的**原生实体**。这一点请尤其注意，模块间所有的实体交互都是用封装实体，只有静态数据查询（表现为seer中的`xxxXMLInfo`）才会返回原生实体。

部分实体同时兼容静态数据和动态数据的信息存储，同时如果有只绑定到自身的静态信息查询，那么还会有额外的getter。但是注意，实体类不包含操作，只作为实体对象传输的中介，因此不可以有任何动态交互（收发包操作）。也就是说，在该设计原则下，所有的实体类无法自行获取并更新绑定玩家的实例实体所拥有的数据，而必须在外部通过SAEngine模块获取后，手动更新。

## 3. 载入器`\Loader`

提供注入功能。在使用sac时，**必须先使用loader进行注入**。

注入涉及两个变量：SeerH5Ready和SacReady，只有它们均为true的时候，才能使用剩余的模块。

实现上，除了loader，其他模块导出的是代理后的esm对象，对esm的取值根据dts中是和原导出一致的，但实际使用的时候，在getter上设置了环境的检测。

注入过程实际上是加载副作用，这些副作用包含在loader下的几个模块中。具体实现上需要注意，对于副作用有以下几种方式：

1. 修改函数本体，直接重写整个函数
2. 使用wrapper对原函数进行封装，详见`wrapper`部分
3. 通过seer中已经存在的EventEmitter，进行事件转发或其他处理

在修改后，sac将会获得以下几种重要能力：

1. 注入自定义的事件钩子，可以使用`SAEventTarget`统一监听事件
2. 在devtool中显示seer客户端源代码，方便调试
3. 其余一些内置修改，这些修改和一些关键功能/特性挂钩，且较为底层，应该尽早修改（区别于下方Functions中的helper）

目前载入器内部下分以下模块：

- `loader\event.ts`负责hook的注入和转发
- `loader\internal.ts`负责游戏内部功能的修改

至于其他的副作用修改，见`Functions`模块

##  4. 常用封装功能`\Functions`

相当于内建的模组，行为上和模组一致，除了模块在评估的时候，会将自己主动注册到模组的manger中，不需要手动开启。所有上述模块的简单逻辑无法实现的内容，都可以在这其中实现。典型功能有换精灵背包和压血。关于模组系统，将在后面进行说明。

该模块下分三个子包

- `Function\module`
- `Function\internal`
- `Function\helper`

其功能区别在于：

- module下的模块将对游戏的特定module进行修改，而且是直接影响ui层的修改，大多需要配合module/panel操作相关功能（UIUtils模块下）和hooks订阅（EventHandler模块下）进行操作。
- internal模块会对客户端核心进行一些hack（见loader模块的介绍），使游戏客户端更易使用，但是这些修改主要是影响表层游戏体验。
- helper模块不需要和ui交互，但是会导出一些函数，这些函数可以在SAMod内访问，也可以通过SAFunc直接访问，主要是考虑到便捷性。

## 5. 事件订阅派发`\EventHandler`

该模块负责维护一个发布订阅中心，维护一组常用的事件订阅模式。根据需求，目前仅提供ui层的module相关hook的一个发布订阅中心。

## 6. 精灵管理`\Pet`

该模块负责维护和精灵操作的相关内容。根据游戏本身的内容与性质，精灵养成与战斗是游戏最主要的两个部分。因此，在考虑sac的逻辑层次时，应该建立pet和battle两个同级，其他都围绕这两个进行的结构。同时由于养成和战斗是分离互斥的，故养成功能专门由`Pet`模块提供，战斗功能则由`Battle`提供。

pet模块提供以下功能（注意，全部返回promise，保证收包后resolve，下列操作全部涉及一次甚至多次收发包操作）：

- 获取背包列表，目前支持主背包和备战背包。
- 查询仓库内精灵，返回的是promise列表，支持收藏和主仓库
- 查询精灵对象by ct/对象，支持任意位置，返回实体对象（获取精灵实体信息）
- 查询精灵对象by ct/对象缓存版，从游戏内缓存获取，支持任意位置，返回实体对象（获取精灵实体信息）
- 查询精灵位置by ct/对象，返回位置（定位精灵）
- 给精灵使用物品（ct/对象，itemId/对象）（不只是血药，常用物品id见Constant）
- 设置默认精灵（ct/对象，需要精灵在背包内）
- 查询默认精灵，返回对象
- 设置精灵位置，该功能内部需要进行多次收发包。
- 治疗一只精灵（ct/对象，需要精灵在背包内）
- 治疗背包全部精灵
- 设置自动治疗
- 查询自动治疗状态
- 精灵放入仓库（ct/对象，需要精灵在背包内），表现等同游戏客户端中进行“放入仓库”操作
- 内部函数：更新精灵列表信息（背包和仓库）
- 内部函数：查询精灵是否在背包内（不会更新仓库背包和信息）

注意，本模块的功能会尽最大程度保证：

1. 所有的promise等最后一个收包结束才会resolve（包括收尾后负责更新信息的收发包）
2. 所有的动态操作会更新seer客户端内部缓存，刷新最新的精灵信息，但是不能保证和ui同步（有额外的内建模组支持）

> Q：为什么不涉及一个统一的获取列表函数？
>
> A：这是游戏内逻辑，性能，需求三方综合下来（目前的）结果。
>
> 首先，逻辑上，seer内部对仓库精灵和背包精灵的处理就是不同的，想由背包精灵拿到原生精灵对象很容易，但是仓库内不行。仓库内的对象是极度简化后的结构，加上精灵数量多，那么从性能上，游戏内想要查询仓库精灵时需要对每个精灵做完整信息的查询，这个过程是涉及收发包的。需求上，大多数时候我们关心的是背包内精灵的详细信息。故api涉及为仓库与背包分开查询。

## 7.战斗管理`\Battle`

这个模块是sac中最核心的一部分，因为一个登陆器去除pvp，最大的价值就是解放pve的双手。

我们先从需求入手，这个登陆器在未来是一定支持自己写关卡模组的，那么写一个关卡模组，我们需要做什么，有需要sac这样的库提供什么？

首先，基本上99%的关卡，都需要pve，那么pve的进行，就有一个入口。也就是，执行某个发包后，战斗就会开始。

幸好这一点，seerh5的默认实现大部分帮我们做完了，我们大多数时候，只需要一个合适的发包，就能进入战斗。  

当战斗开始后，我们有一系列的hooks，代表战斗开始，回合开始（在战斗开始的同时也会触发第一回合的回合开始），战斗结束。

我们在每个回合开始，需要干两件事：

- 综合场上的信息
- 对精灵执行操作

抽象出来，就是一个这样的模型：

- 进入战斗
- hook到回合开始
  - 获得信息
    - 回合信息
    - 精灵信息
  - 执行操作
    - 逃跑
    - 磕药
    - 出招
    - 超时（执行默认操作）
    - ~~捕捉~~

了解以上模型后，下面是本模块的设计思路：

首先使用SAEventTarget订阅相关hook。

然后使用provider获得信息。

使用operator进行操作。

使用manager获得自动战斗操作的**单例**对象。

manager会进行自动战斗的调度，包括两个方面：

- 基于promise的战斗回调，在一场战斗结束后resolve
- 基于strategy的战斗逻辑，有一些相关的辅助函数等

详见`strategy`和`MoveModule`的说明。

## 8. 模组系统`\ModManger`

该模块导出一个`ModManger`。负责mod的注册，运行。

mod的生命周期目前如下：

调用注册`register`时，实例化并存入SAMod中。

在Loader发出SacReady事件后（即游戏已经登录，进入主页面），依次调用所有mod的init函数进行初始化。

然后可以手动调用其中的方法。

如果想使用hooks，请自行调用EventHandler的导出（订阅器）或者common的导出（SAEventTarget）来在init中注册事件与回调。

## 9. UI操作`\UIUtils`

目前主要是一些ui相关的工具函数。

## 10. 其他

### createLocalStorageProxy

`createLocalStorageProxy`创建一个代理对象，这个对象可以同原来的对象一般正常访问，但是同时通过对ref进行set时，更改会自动序列化到localStorage中，或者可以使用use方法，该方法使用思路同`immer`中的`produce`，在里面正常更改对象即可。

可以由ref属性获取到真正的对象。使用实例见`App`的`BattleManager.tsx`。